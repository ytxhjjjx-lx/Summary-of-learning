# JS异步编程
JavaScript语言的一大特点就是单线程,单线程意味着,所有任务需要排队,前一个任务结束,才会执行后一个任务,如果前一个任务耗时很长,后一个任务就只能一直等着;

##### 1.任务
任务,分成两种,一种是同步任务,另一种是异步任务;

###### 同步任务
在主线程上排队执行的任务,只有前一个任务执行完毕,才能执行后一个任务;

###### 异步任务
不进入主线程、而进入"任务队列"的任务,只有"任务队列"通知主线程,某个异步任务可以执行了,该任务才会进入主线程执行;


##### 2.主线程
JS 只有一个线程,称之为主线程;  
事件循环是主线程中执行栈里的代码执行完毕之后,才开始执行的;  
主线程中要执行的代码时间过长,会阻塞事件循环的执行,也就会阻塞异步操作的执行;   
只有当主线程中执行栈为空的时候(即同步代码执行完后),才会进行事件循环来观察要执行的事件回调,当事件循环检测到任务队列中有事件,就取出相关回调放入执行栈中由主线程执行;

##### 3.任务队列
异步操作,会将相关回调,添加到任务队列中;  
不同的异步操作,添加到任务队列的时机不同;

##### 4.事件循环
JS 会创建一个类似于 while (true) 的循环,每执行一次循环体的过程称之为 Tick,每次 Tick 的过程就是查看是否有待处理事件,如果有则取出相关事件及回调函数放入执行栈中由主线程执行;  
待处理的事件,会存储在一个任务队列中,每次 Tick 会查看任务队列中是否有需要执行的任务;


## 1.异步执行的运行机制
1.所有同步任务,都在主线程上执行,形成一个执行栈;     

2.主线程之外,还存在一个"任务队列",只要异步任务有了运行结果,就在"任务队列"之中放置一个事件;

3.一旦"执行栈"中的所有同步任务执行完毕,系统就会读取"任务队列",看看里面有哪些事件,那些对应的异步任务,于是结束等待状态,进入执行栈,开始执行;

4.主线程不断重复上面的第三步;


## 2.常见的异步任务
###### 1.onclick等事件 
由浏览器内核的 DOM Binding 模块来处理,当事件触发的时候,回调函数会立即添加到任务队列中;

###### 2.setTimeout 
会由浏览器内核的 timer 模块,来进行延时处理,当时间到达的时候,才会将回调函数添加到任务队列中;

```
setTimeout(function(){
  console.log('1');
},0);

console.log('2');
```
setTimeout是一个异步的操作,当时间到达之后,回调函数会被添加到任务队列中;  
主线程中的所有任务结束之后,才会去参看任务队列中的任务,输出 1;


###### 3.ajax 
会由浏览器内核的 network 模块来处理,在网络请求完成返回之后,才将回调添加到任务队列中;


## 3.异步编程的四种方法
除onclick等事件、ajax请求这些天生的异步任务,有一些函数本身很耗时,其他函数依赖这个函数的执行结果,这时需要我们手动进行异步编程;

### 1.回调函数(回调可以进行同步也可以异步调用，但是 Node.js 提供的 API 大多都是异步回调的)

假设:  两个函数f1和f2,f1很耗时,f2需要等待f1的执行结果;
 **使用setTimeout函数,将f1变成异步操作,不会影响程序运行; f1运行结束后,再运行f2;** 

```
function f1(callback){
　　setTimeout(function () {
　　　　// f1的任务代码
　　　　callback();
　　　}, 1000);
　}
　　
f1(f2);
```
###### 使用回调函数的优缺点
优点:    
简单、容易理解和部署;   

缺点:   
不利于代码的阅读和维护,各个部分之间高度耦合,流程会很混乱(不能直接看出f1和f2之间的依赖关系)


### 2.事件监听(发布订阅)
 **任务的执行,不取决于代码的顺序,而取决于某个事件是否发生;** 

```
f1.on('done', f2);

function f1(){
　　setTimeout(function () {
　　　　// f1的任务代码
　　　　f1.trigger('done');
　　}, 1000);
}
```
f1.trigger('done')表示,执行完成后,立即触发done事件,从而开始执行f2;

 **事件机制的优缺点**   

###### 优点
可以绑定多个事件,每个事件可以指定多个回调函数; 可以"去耦合",有利于实现模块化;

###### 缺点
整个程序,都要变成事件驱动型;运行流程会变得不清晰;



3.   es2015  promise(解决回调地狱),
4.   es2016  generator



4.   es2017  asycn